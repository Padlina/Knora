@*
 * Copyright © 2015 Lukas Rosenthaler, Benjamin Geer, Ivan Subotic,
 * Tobias Schweizer, André Kilchenmann, and André Fatton.
 *
 * This file is part of Knora.
 *
 * Knora is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Knora is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with Knora.  If not, see <http://www.gnu.org/licenses/>.
 *@

@import org.knora.webapi._

@**
 * Gets the graph of resources reachable via links from some initial resource, up to a specified depth. Includes
 * all links that are subproperties of knora-base:hasLinkTo, but excludes links that are subproperties of
 * knora-base:isPartOf.
 *
 * This query requires GraphDB, and uses inference. Many thanks to Damyan Ognyanov for the design of this query.
 *
 * @param triplestore the name of the triplestore being used.
 * @param initialResourceIri the IRI of the initial resource.
 * @param maxDepth the maximum allowed distance from the initial resource to each resource returned by the query.
 *@
@(triplestore: String,
  initialResourceIri: IRI,
  maxDepth: Int)

@if(!triplestore.startsWith("graphdb")) {
    @{throw SparqlGenerationException("This SPARQL template requires GraphDB"); ()}
}

PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX onto: <http://www.ontotext.com/>
PREFIX knora-base: <http://www.knora.org/ontology/knora-base#>

SELECT ?resource ?resourceLabel ?resourceOwner ?resourceProject ?resourcePermissions ?path ?depth ?direction
FROM NAMED onto:explicit
WHERE
{
    {
        # Get outbound paths.

        SELECT ?resource ?resourceLabel ?resourceOwner ?resourceProject ?resourcePermissions
               (CONCAT('[ ', GROUP_CONCAT(CONCAT(
                             '{ "source": "', STR(?intermediateResource1),
                             '", "prop": "', STR(?prop),
                             '", "linkValueOwner": "', STR(?linkValueOwner),
                             '", "linkValueProject": "', STR(?linkValueProject),
                             '", "linkValuePermissions": "', STR(?linkValuePermissions),
                             '", "target": "', STR(?intermediateResource2), '" }'); separator=', '), ' ]') AS ?path)
               (COUNT(?intermediateResource1) AS ?depth)
               ("outbound" AS ?direction)
        WHERE
        {
            {
                # Get all resources reachable via outbound links from the initial resource.

                SELECT ?initialResource ?resource
                WHERE
                {
                    BIND(IRI("@initialResourceIri") AS ?initialResource)

                    # Find all intermediate nodes reachable transitively via knora-base:hasLinkTo from ?initialResource.
                    ?initialResource knora-base:hasLinkTo* ?intermediateResource .

                    # Filter out intermediate nodes that are bound to ?intermediateResource if these use an unwanted link
                    # on the last hop from some other node that is also reachable from ?initialResource.

                    OPTIONAL
                    {
                        ?excludedResource knora-base:isPartOf ?intermediateResource .
                        ?initialResource knora-base:hasLinkTo* ?excludedResource .
                    }

                    FILTER(!BOUND(?excludedResource))

                    OPTIONAL
                    {
                        ?deletedResource knora-base:hasLinkTo ?intermediateResource .
                        ?deletedResource knora-base:isDeleted true .
                        ?initialResource knora-base:hasLinkTo* ?deletedResource .
                    }

                    FILTER(!BOUND(?deletedResource))

                    # Get the last hop from the intermediate node to ?resource.
                    ?intermediateResource knora-base:hasLinkTo ?resource .

                    # Filter it out if it is an unwanted one.
                    MINUS
                    {
                        ?intermediateResource knora-base:isPartOf ?resource .
                    }

                    ?intermediateResource knora-base:isDeleted false .
                    ?resource knora-base:isDeleted false .
                }
            }

            # Get the permission-relevant information and label from ?resource.

            ?resource knora-base:attachedToUser ?resourceOwner .
            ?resource knora-base:attachedToProject ?resourceProject .
            ?resource knora-base:hasPermissions ?resourcePermissions .
            ?resource rdfs:label ?resourceLabel .

            # Get each pair of nodes along the path from ?initialResource to ?resource.

            ?initialResource knora-base:hasLinkTo* ?intermediateResource1 .
            ?intermediateResource1 knora-base:hasLinkTo ?intermediateResource2 .
            ?intermediateResource2 knora-base:hasLinkTo* ?resource .

            # Get the explicit property used for each edge, along with the permission-relevant information
            # in the knora-base:LinkValue reification of the link.

            OPTIONAL
            {
                GRAPH onto:explicit
                {
                    ?intermediateResource1 ?prop ?intermediateResource2 .

                    ?linkValue rdf:type knora-base:LinkValue ;
                        rdf:subject ?intermediateResource1 ;
                        rdf:predicate ?prop ;
                        rdf:object ?intermediateResource2 ;
                        knora-base:isDeleted false ;
                        knora-base:attachedToUser ?linkValueOwner ;
                        knora-base:hasPermissions ?linkValuePermissions .


                    OPTIONAL {
                        ?linkValue knora-base:attachedToProject ?maybeLinkValueProject .
                    }
                    
                    BIND(COALESCE(?maybeLinkValueProject, "") AS ?linkValueProject)

                    BIND(IRI(CONCAT(STR(?prop), "Value")) AS ?linkValueProp)
                    ?intermediateResource1 ?linkValueProp ?linkValue .
                }
            }
        }
        GROUP BY ?resource ?resourceLabel ?resourceOwner ?resourceProject ?resourcePermissions
        HAVING(COUNT(?intermediateResource1) <= @maxDepth)
    }
    UNION
    {
        # Get inbound paths.

        SELECT ?resource ?resourceLabel ?resourceOwner ?resourceProject ?resourcePermissions
               (CONCAT('[ ', GROUP_CONCAT(CONCAT(
                             '{ "source": "', STR(?intermediateResource1),
                             '", "prop": "', STR(?prop),
                             '", "linkValueOwner": "', STR(?linkValueOwner),
                             '", "linkValueProject": "', STR(?linkValueProject),
                             '", "linkValuePermissions": "', STR(?linkValuePermissions),
                             '", "target": "', STR(?intermediateResource2), '" }'); separator=', '), ' ]') AS ?path)
               (COUNT(?intermediateResource1) AS ?depth)
               ("inbound" AS ?direction)
        WHERE
        {
            {
                # Get all resources reachable via inbound links from the initial resource.

                SELECT ?initialResource ?resource
                WHERE
                {
                    BIND(IRI("@initialResourceIri") AS ?initialResource)

                    # Find all intermediate nodes that can reaqch ?initialResource transitively via knora-base:hasLinkTo.
                    ?intermediateResource knora-base:hasLinkTo* ?initialResource .

                    # Filter out intermediate nodes that are bound to ?intermediateResource if these use an unwanted link
                    # on the last hop from some other node that can also reach ?initialResource.

                    OPTIONAL
                    {
                        ?intermediateResource knora-base:isPartOf ?excludedResource .
                        ?excludedResource knora-base:hasLinkTo* ?initialResource .
                    }

                    FILTER(!BOUND(?excludedResource))

                    OPTIONAL
                    {
                        ?intermediateResource knora-base:hasLinkTo ?deletedResource .
                        ?deletedResource knora-base:isDeleted true .
                        ?deletedResource knora-base:hasLinkTo* ?initialResource .
                    }

                    FILTER(!BOUND(?deletedResource))

                    # Get the last hop from the intermediate node to ?initialResource.
                    ?resource knora-base:hasLinkTo ?intermediateResource .

                    # Filter it out if it is an unwanted one.
                    MINUS
                    {
                        ?intermediateResource knora-base:isPartOf ?resource .
                    }

                    ?intermediateResource knora-base:isDeleted false .
                    ?resource knora-base:isDeleted false .
                }
            }

            # Get the permission-relevant information and label from ?resource.

            ?resource knora-base:attachedToUser ?resourceOwner .
            ?resource knora-base:attachedToProject ?resourceProject .
            ?resource knora-base:hasPermissions ?resourcePermissions .
            ?resource rdfs:label ?resourceLabel .

            # Get each pair of nodes along the path from ?resource to ?initialResource.

            ?resource knora-base:hasLinkTo* ?intermediateResource1 .
            ?intermediateResource1 knora-base:hasLinkTo ?intermediateResource2 .
            ?intermediateResource2 knora-base:hasLinkTo* ?initialResource .

            # Get the explicit property used for each edge, along with the permission-relevant information
            # in the knora-base:LinkValue reification of the link.

            OPTIONAL
            {
                GRAPH onto:explicit
                {
                    ?intermediateResource1 ?prop ?intermediateResource2 .

                    ?linkValue rdf:type knora-base:LinkValue ;
                        rdf:subject ?intermediateResource1 ;
                        rdf:predicate ?prop ;
                        rdf:object ?intermediateResource2 ;
                        knora-base:isDeleted false ;
                        knora-base:attachedToUser ?linkValueOwner ;
                        knora-base:hasPermissions ?linkValuePermissions .

                    OPTIONAL {
                        ?linkValue knora-base:attachedToProject ?maybeLinkValueProject .
                    }

                    BIND(COALESCE(?maybeLinkValueProject, "") AS ?linkValueProject)

                    BIND(IRI(CONCAT(STR(?prop), "Value")) AS ?linkValueProp)
                    ?intermediateResource1 ?linkValueProp ?linkValue .
                }
            }
        }
        GROUP BY ?resource ?resourceLabel ?resourceOwner ?resourceProject ?resourcePermissions
        HAVING(COUNT(?intermediateResource1) <= @maxDepth)
    }
}
