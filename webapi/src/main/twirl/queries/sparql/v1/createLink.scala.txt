@*
 * Copyright © 2015 Lukas Rosenthaler, Benjamin Geer, Ivan Subotic,
 * Tobias Schweizer, André Kilchenmann, and André Fatton.
 *
 * This file is part of Knora.
 *
 * Knora is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Knora is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with Knora.  If not, see <http://www.gnu.org/licenses/>.
 *@

@import org.knora.webapi._
@import org.knora.webapi.twirl.SparqlTemplateLinkUpdate
@import org.knora.webapi.messages.v1respondermessages.valuemessages._

@**
 * Inserts a new link between resources.
 *
 * @param dataNamedGraph the named graph in which the project stores its data.
 * @param triplestore the name of the triplestore being used. The template uses this value to exclude inferred
                      results from the WHERE clause of the update.
 * @param linkSourceIri the resource that is the source of the link.
 * @param linkUpdate a [[LinkUpdate]] object describing the link to insert.
 * @param maybeComment an optional comment on the link.
 * @param updateResourceLastModificationDate if true, update the resource's knora-base:lastModificationDate.
 *
 * To find out whether the update succeeded, the application must query the link.
 *@
@(dataNamedGraph: IRI,
  triplestore: String,
  linkSourceIri: IRI,
  linkUpdate: SparqlTemplateLinkUpdate,
  maybeComment: Option[String],
  updateResourceLastModificationDate: Boolean)

prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix owl: <http://www.w3.org/2002/07/owl#>
prefix knora-base: <http://www.knora.org/ontology/knora-base#>

DELETE {
    GRAPH ?dataNamedGraph {
        @if(updateResourceLastModificationDate) {
            @* Delete the link source's last modification date so we can update it. *@
            ?linkSource knora-base:lastModificationDate ?linkSourceLastModificationDate .

            @* If an existing LinkValue needs to be updated, detach it from the link source. *@
            @if(linkUpdate.linkValueExists) {
                ?linkSource ?linkValueProperty ?existingLinkValue .
            }
        }
    }
} INSERT {
    GRAPH ?dataNamedGraph {
        @* Insert a direct link between the source and target resources. *@
        @if(linkUpdate.insertDirectLink) {
            ?linkSource ?linkProperty ?linkTarget .
        } else {
            @{throw SparqlGenerationException(s"LinkUpdate.insertDirectLink must be true in this SPARQL template"); ()}
        }

        @* Insert a LinkValue describing the link. *@
        ?newLinkValue rdf:type knora-base:LinkValue ;
            rdf:subject ?linkSource ;
            rdf:predicate ?linkProperty ;
            rdf:object ?linkTarget ;
            knora-base:valueHasRefCount @linkUpdate.newReferenceCount ;
            @maybeComment match {
                case Some(comment) => {
                    knora-base:valueHasComment """@comment""" ;
                }

                case None => {}
            }
            knora-base:valueHasOrder ?nextOrder ;
            knora-base:valueCreationDate ?currentTime .

        @for(assertion <- linkUpdate.permissionRelevantAssertions) {
            ?newLinkValue <@assertion._1> <@assertion._2> .
        }

        @* Attach the new LinkValue to its containing resource. *@
        ?linkSource ?linkValueProperty ?newLinkValue .

        @if(updateResourceLastModificationDate) {
            @* Update the link source's last modification date. *@
            ?linkSource knora-base:lastModificationDate ?currentTime .
        }
    }
}
@*

GraphDB's consistency checking requires reasoning, but reasoning interferes with certain things
in the WHERE clauses of our SPARQL updates, so we set a GraphDB-specific flag to return only
explicit statements in the WHERE clause here.

*@
@triplestore match {
    case "graphdb" | "graphdb-free" => {
        USING <http://www.ontotext.com/explicit>
    }

    case other => {}
}
WHERE {
    BIND(IRI("@dataNamedGraph") AS ?dataNamedGraph)
    BIND(IRI("@linkSourceIri") AS ?linkSource)
    BIND(IRI("@linkUpdate.linkPropertyIri") AS ?linkProperty)
    BIND(IRI("@{linkUpdate.linkPropertyIri}Value") AS ?linkValueProperty)
    BIND(IRI("@linkUpdate.newLinkValueIri") AS ?newLinkValue)
    BIND(IRI("@linkUpdate.linkTargetIri") AS ?linkTarget)
    BIND(NOW() AS ?currentTime)

    @* Make sure the link source and target are actually resources. *@

    ?linkSource rdf:type ?linkSourceClass .
    ?linkTarget rdf:type ?linkTargetClass .

    ?linkSourceClass rdfs:subClassOf+ knora-base:Resource .
    ?linkTargetClass rdfs:subClassOf+ knora-base:Resource .

    @* Do nothing if the target resource belongs to the wrong OWL class. *@

    ?linkProperty knora-base:objectClassConstraint ?expectedTargetClass .
    ?linkTargetClass rdfs:subClassOf* ?expectedTargetClass .

    @* Do nothing if the source or target resource doesn't exist or is marked as deleted. *@

    MINUS {
        ?linkSource knora-base:isDeleted true .
    }

    MINUS {
        ?linkTarget knora-base:isDeleted true .
    }

    @* Do nothing if the source resource's OWL class has no cardinality for the link property. *@

    ?linkSourceClass rdfs:subClassOf* ?restriction .
    ?restriction a owl:Restriction .
    ?restriction owl:onProperty ?linkProperty .

    @if(linkUpdate.directLinkExists) {
        @{throw SparqlGenerationException(s"linkUpdate.directLinkExists must be false in this SPARQL template"); ()}
    }

    @if(linkUpdate.linkValueExists) {
        @{throw SparqlGenerationException(s"linkUpdate.linkValueExists must be false in this SPARQL template"); ()}
    }

    @*

    Generate knora-base:valueHasOrder for the new LinkValue. If the link value property already has one or more
    (non-deleted) LinkValues in the resource, find the one with the highest order, add 1 to its order, and give
    the resulting order to the new LinkValue. Otherwise, give the new LinkValue an order of 0.

    *@

    {
        SELECT ((MAX(?order)) AS ?maxOrder) (IF(BOUND(?maxOrder), ?maxOrder + 1, 0) AS ?nextOrder)
        WHERE {
            BIND(IRI("@linkSourceIri") AS ?linkSource)
            BIND(IRI("@{linkUpdate.linkPropertyIri}Value") AS ?linkValueProperty)

            ?linkSource ?linkValueProperty ?otherLinkValue .
            ?otherLinkValue knora-base:valueHasOrder ?order .

            MINUS {
                ?otherLinkValue knora-base:isDeleted true .
            }
        }
    }

    @if(updateResourceLastModificationDate) {
        @* Get the link source's last modification date, if it has one, so we can update it. *@

        OPTIONAL {
            ?linkSource knora-base:lastModificationDate ?linkSourceLastModificationDate .
        }
    }
}
